// Bestand: api/dataset.js
import { GoogleGenAI } from '@google/genai';
import { createClient } from '@vercel/kv';

// Cache sleutels
const CACHE_KEY = 'pulse_dataset_cache';
const CACHE_DURATION_MS = 2 * 60 * 60 * 1000; // 2 uur in milliseconden

// Database Client
const kv = createClient({
    url: process.env.KV_REST_API_URL,
    token: process.env.KV_REST_API_TOKEN,
});

// AI Client
const apiKey = process.env.GEMINI_API_KEY;
const ai = apiKey ? new GoogleGenAI({ apiKey }) : null;

// Functie om de volledige dataset van Gemini te genereren
async function generateFullDataset() {
    if (!ai) {
        throw new Error('Gemini API Sleutel ontbreekt of kon niet worden geïnitialiseerd.');
    }

    const prompt = `
        Je bent een Game Master voor een extreem drankspel, PULSE. Genereer een JSON array met 400 objecten in totaal. 
        
        Splits dit strikt in twee categorieën:
        1.  200 objecten voor de categorie "Borrel Pulse".
        2.  200 objecten voor de categorie "Deep Talk".
        
        **Regels voor Borrel Pulse (GEHEIME OPDRACHT):**
        - De opdrachten moeten 'doe of faal' opdrachten zijn (een geheime actie, verbale restrictie, of fysieke uitdaging) die {player} moet volhouden tot de beurt weer bij hem/haar is, of die een specifieke faalconditie heeft (bijv. iemand merkt het op).
        - De 'type' moet "GEHEIME OPDRACHT" zijn.
        
        **Regels voor Deep Talk (DEEP DIVE):**
        - De vragen moeten diepgaande en emotioneel onthullende vragen zijn.
        - De 'type' moet "DEEP DIVE" zijn.
        
        Elk object moet strikt de volgende structuur hebben:
        {
          "category": "Categorie naam",
          "type": "GEHEIME OPDRACHT" of "DEEP DIVE",
          "question": "De opdracht/vraag. Gebruik de placeholder {player} voor de huidige speler.",
          "consequence": "De te nemen consequentie als de speler weigert/faalt. (bijv. 'Drie shots', 'Vijf slokken', 'Neem een ongemakkelijke selfie')"
        }
        
        Zorg voor een perfecte, geldige JSON-array, zonder extra tekst of markdown erbuiten.
    `;

    try {
        console.log("CACHE VERLOPEN: Nieuwe dataset genereren via Gemini...");
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: [{ role: "user", parts: [{ text: prompt }] }],
            config: {
                responseMimeType: "application/json",
            }
        });

        const jsonResponse = JSON.parse(response.text.trim());
        
        if (!Array.isArray(jsonResponse) || jsonResponse.length === 0) {
            throw new Error("Gemini gaf een ongeldig of leeg JSON-array terug.");
        }

        return jsonResponse;

    } catch (error) {
        console.error('Fout bij het genereren van de AI-content:', error);
        throw new Error('Fout bij het genereren van de AI-content.');
    }
}

// Vercel Serverless Function Handler
export default async function handler(req, res) {
    if (req.method !== 'GET') {
        return res.status(405).json({ error: 'Methode niet toegestaan.' });
    }

    try {
        // 1. Controleer de cache
        const cache = await kv.get(CACHE_KEY);

        if (cache) {
            const { timestamp, data } = cache;
            const now = Date.now();
            
            // 2. Cache is nog geldig (binnen 2 uur)
            if (now - timestamp < CACHE_DURATION_MS) {
                console.log(`Cache hit. Dataset is ${((now - timestamp) / 1000 / 60).toFixed(0)} minuten oud.`);
                return res.status(200).json(data);
            }
        }

        // 3. Cache is verlopen of bestaat niet -> Genereer nieuwe data
        const newDataset = await generateFullDataset();
        const newTimestamp = Date.now();

        // 4. Sla de nieuwe data op in de cache
        const cacheObject = { timestamp: newTimestamp, data: newDataset };
        await kv.set(CACHE_KEY, cacheObject);
        console.log(`Dataset opgeslagen in KV cache met timestamp ${newTimestamp}`);

        // 5. Stuur het geldige JSON-antwoord terug naar de frontend
        return res.status(200).json(newDataset);

    } catch (error) {
        console.error('Hoofdfout in dataset handler:', error.message);
        
        // Probeer in geval van een fatale fout (bv. Gemini-fout) de oude cache te retourneren
        try {
             const cache = await kv.get(CACHE_KEY);
             if (cache) {
                console.warn("Kon niet vernieuwen, maar oude cache teruggegeven.");
                return res.status(200).json(cache.data);
             }
        } catch (e) {
            // Als alles faalt
        }
        
        // Definitieve foutmelding
        return res.status(500).json({ error: 'Interne serverfout bij het ophalen van de dataset.', details: error.message });
    }
}